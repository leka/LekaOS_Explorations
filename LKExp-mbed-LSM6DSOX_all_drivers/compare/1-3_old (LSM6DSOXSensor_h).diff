--- /mbed-ST_LSM6DSOX/LSM6DSOXSensor.h  (last commit)
+++ /github-stm32duino_LSM6DSOX/LSM6DSOXSensor.h (commit d00c52d7eebe36cc1abd318d934f48852e3b00ea)
@@ -4,7 +4,7 @@
  * @author  SRA
  * @version V1.0.0
  * @date    February 2019
- * @brief   Abstract Class of an LSM6DSOX Inertial Measurement Unit (IMU) 6 axes
+ * @brief   Abstract Class of an LSM6DSOX Inertial Measurement Unit (IMU) 3 axes
  *          sensor.
  ******************************************************************************
  * @attention
@@ -44,11 +44,10 @@
 
 
 /* Includes ------------------------------------------------------------------*/
-#include "DevI2C.h"
+
+#include "Wire.h"
+#include "SPI.h"
 #include "lsm6dsox_reg.h"
-#include "MotionSensor.h"
-#include "GyroSensor.h"
-#include <assert.h>
 
 /* Defines -------------------------------------------------------------------*/
 
@@ -68,9 +67,15 @@
 
 typedef enum
 {
+  LSM6DSOX_OK = 0,
+  LSM6DSOX_ERROR =-1
+} LSM6DSOXStatusTypeDef;
+
+typedef enum
+{
   LSM6DSOX_INT1_PIN,
   LSM6DSOX_INT2_PIN,
-} LSM6DSOX_Interrupt_Pin_t;
+} LSM6DSOX_SensorIntPin_t;
 
 typedef struct
 {
@@ -88,146 +93,95 @@
 /* Class Declaration ---------------------------------------------------------*/
    
 /**
- * Abstract class of an LSM6DSOX Inertial Measurement Unit (IMU) 6 axes
+ * Abstract class of an LSM6DSOX Inertial Measurement Unit (IMU) 3 axes
  * sensor.
  */
-class LSM6DSOXSensor : public MotionSensor, public GyroSensor
+class LSM6DSOXSensor
 {
   public:
-    enum SPI_type_t {SPI3W, SPI4W};
-    LSM6DSOXSensor(SPI *spi, PinName cs_pin, PinName int1_pin=NC, PinName int2_pin=NC, SPI_type_t spi_type=SPI4W);
-    LSM6DSOXSensor(DevI2C *i2c, uint8_t address=LSM6DSOX_I2C_ADD_H, PinName int1_pin=NC, PinName int2_pin=NC);
-    virtual int init(void *init);
-    virtual int read_id(uint8_t *id);
-    virtual int get_x_axes(int32_t *acceleration);
-    virtual int get_g_axes(int32_t *angular_rate);
-    virtual int get_x_sensitivity(float *sensitivity);
-    virtual int get_g_sensitivity(float *sensitivity);
-    virtual int get_x_axes_raw(int16_t *value);
-    virtual int get_g_axes_raw(int16_t *value);
-    virtual int get_x_odr(float *odr);
-    virtual int get_g_odr(float *odr);
-    virtual int set_x_odr(float odr);
-    virtual int set_g_odr(float odr);
-    virtual int get_x_fs(float *full_scale);
-    virtual int get_g_fs(float *full_scale);
-    virtual int set_x_fs(float full_scale);
-    virtual int set_g_fs(float full_scale);
-    int enable_x(void);
-    int enable_g(void);
-    int disable_x(void);
-    int disable_g(void);
-    int enable_free_fall_detection(LSM6DSOX_Interrupt_Pin_t pin = LSM6DSOX_INT1_PIN);
-    int disable_free_fall_detection(void);
-    int set_free_fall_threshold(uint8_t thr);
-    int set_free_fall_duration(uint8_t dur);
-    int enable_pedometer(void);
-    int disable_pedometer(void);
-    int get_step_counter(uint16_t *step_count);
-    int reset_step_counter(void);
-    int enable_tilt_detection(LSM6DSOX_Interrupt_Pin_t pin = LSM6DSOX_INT1_PIN);
-    int disable_tilt_detection(void);
-    int enable_wake_up_detection(LSM6DSOX_Interrupt_Pin_t pin = LSM6DSOX_INT2_PIN);
-    int disable_wake_up_detection(void);
-    int set_wake_up_threshold(uint8_t thr);
-    int set_wake_up_duration(uint8_t dur);
-    int enable_single_tap_detection(LSM6DSOX_Interrupt_Pin_t pin = LSM6DSOX_INT1_PIN);
-    int disable_single_tap_detection(void);
-    int enable_double_tap_detection(LSM6DSOX_Interrupt_Pin_t pin = LSM6DSOX_INT1_PIN);
-    int disable_double_tap_detection(void);
-    int set_tap_threshold(uint8_t thr);
-    int set_tap_shock_time(uint8_t time);
-    int set_tap_quiet_time(uint8_t time);
-    int set_tap_duration_time(uint8_t time);
-    int enable_6d_orientation(LSM6DSOX_Interrupt_Pin_t pin = LSM6DSOX_INT1_PIN);
-    int disable_6d_orientation(void);
-    int set_6d_orientation_threshold(uint8_t thr);
-    int get_6d_orientation_xl(uint8_t *xl);
-    int get_6d_orientation_xh(uint8_t *xh);
-    int get_6d_orientation_yl(uint8_t *yl);
-    int get_6d_orientation_yh(uint8_t *yh);
-    int get_6d_orientation_zl(uint8_t *zl);
-    int get_6d_orientation_zh(uint8_t *zh);
-    int get_event_status(LSM6DSOX_Event_Status_t *status);
-    int read_reg(uint8_t reg, uint8_t *data);
-    int write_reg(uint8_t reg, uint8_t data);
-    int set_interrupt_latch(uint8_t status);
-    int get_x_drdy_status(uint8_t *status);
-    int set_x_self_test(uint8_t status);
-    int get_g_drdy_status(uint8_t *status);
-    int set_g_self_test(uint8_t status);
-    int get_fifo_num_samples(uint16_t *num_samples);
-    int get_fifo_full_status(uint8_t *status);
-    int set_fifo_int1_fifo_full(uint8_t status);
-    int set_fifo_watermark_level(uint16_t watermark);
-    int set_fifo_stop_on_fth(uint8_t status);
-    int set_fifo_mode(uint8_t mode);
-    int get_fifo_tag(uint8_t *tag);
-    int get_fifo_data(uint8_t *data);
-    int get_fifo_x_axes(int32_t *acceleration);
-    int set_fifo_x_bdr(float bdr);
-    int get_fifo_g_axes(int32_t *angular_velocity);
-    int set_fifo_g_bdr(float bdr);
-    
-    /**
-     * @brief  Attaching an interrupt handler to the INT1 interrupt.
-     * @param  fptr An interrupt handler.
-     * @retval None.
-     */
-    void attach_int1_irq(void (*fptr)(void))
-    {
-        _int1_irq.rise(fptr);
-    }
-
-    /**
-     * @brief  Enabling the INT1 interrupt handling.
-     * @param  None.
-     * @retval None.
-     */
-    void enable_int1_irq(void)
-    {
-        _int1_irq.enable_irq();
-    }
-    
-    /**
-     * @brief  Disabling the INT1 interrupt handling.
-     * @param  None.
-     * @retval None.
-     */
-    void disable_int1_irq(void)
-    {
-        _int1_irq.disable_irq();
-    }
-    
-    /**
-     * @brief  Attaching an interrupt handler to the INT2 interrupt.
-     * @param  fptr An interrupt handler.
-     * @retval None.
-     */
-    void attach_int2_irq(void (*fptr)(void))
-    {
-        _int2_irq.rise(fptr);
-    }
-
-    /**
-     * @brief  Enabling the INT2 interrupt handling.
-     * @param  None.
-     * @retval None.
-     */
-    void enable_int2_irq(void)
-    {
-        _int2_irq.enable_irq();
-    }
-    
-    /**
-     * @brief  Disabling the INT2 interrupt handling.
-     * @param  None.
-     * @retval None.
-     */
-    void disable_int2_irq(void)
-    {
-        _int2_irq.disable_irq();
-    }
+    LSM6DSOXSensor(TwoWire *i2c, uint8_t address=LSM6DSOX_I2C_ADD_H);
+    LSM6DSOXSensor(SPIClass *spi, int cs_pin, uint32_t spi_speed=2000000);
+    LSM6DSOXStatusTypeDef ReadID(uint8_t *Id);
+    LSM6DSOXStatusTypeDef Enable_X();
+    LSM6DSOXStatusTypeDef Disable_X();
+    LSM6DSOXStatusTypeDef Get_X_Sensitivity(float *Sensitivity);
+    LSM6DSOXStatusTypeDef Get_X_ODR(float *Odr);
+    LSM6DSOXStatusTypeDef Set_X_ODR(float Odr);
+    LSM6DSOXStatusTypeDef Get_X_FS(int32_t *FullScale);
+    LSM6DSOXStatusTypeDef Set_X_FS(int32_t FullScale);
+    LSM6DSOXStatusTypeDef Get_X_AxesRaw(int16_t *Value);
+    LSM6DSOXStatusTypeDef Get_X_Axes(int32_t *Acceleration);
+    
+    LSM6DSOXStatusTypeDef Enable_G();
+    LSM6DSOXStatusTypeDef Disable_G();
+    LSM6DSOXStatusTypeDef Get_G_Sensitivity(float *Sensitivity);
+    LSM6DSOXStatusTypeDef Get_G_ODR(float *Odr);
+    LSM6DSOXStatusTypeDef Set_G_ODR(float Odr);
+    LSM6DSOXStatusTypeDef Get_G_FS(int32_t *FullScale);
+    LSM6DSOXStatusTypeDef Set_G_FS(int32_t FullScale);
+    LSM6DSOXStatusTypeDef Get_G_AxesRaw(int16_t *Value);
+    LSM6DSOXStatusTypeDef Get_G_Axes(int32_t *AngularRate);
+    
+    LSM6DSOXStatusTypeDef Read_Reg(uint8_t reg, uint8_t *Data);
+    LSM6DSOXStatusTypeDef Write_Reg(uint8_t reg, uint8_t Data);
+    LSM6DSOXStatusTypeDef Set_Interrupt_Latch(uint8_t Status);
+    
+    LSM6DSOXStatusTypeDef Enable_Free_Fall_Detection(LSM6DSOX_SensorIntPin_t IntPin);
+    LSM6DSOXStatusTypeDef Disable_Free_Fall_Detection();
+    LSM6DSOXStatusTypeDef Set_Free_Fall_Threshold(uint8_t Threshold);
+    LSM6DSOXStatusTypeDef Set_Free_Fall_Duration(uint8_t Duration);
+    
+    LSM6DSOXStatusTypeDef Enable_Pedometer();
+    LSM6DSOXStatusTypeDef Disable_Pedometer();
+    LSM6DSOXStatusTypeDef Get_Step_Count(uint16_t *StepCount);
+    LSM6DSOXStatusTypeDef Step_Counter_Reset();
+    
+    LSM6DSOXStatusTypeDef Enable_Tilt_Detection(LSM6DSOX_SensorIntPin_t IntPin);
+    LSM6DSOXStatusTypeDef Disable_Tilt_Detection();
+    
+    LSM6DSOXStatusTypeDef Enable_Wake_Up_Detection(LSM6DSOX_SensorIntPin_t IntPin);
+    LSM6DSOXStatusTypeDef Disable_Wake_Up_Detection();
+    LSM6DSOXStatusTypeDef Set_Wake_Up_Threshold(uint8_t Threshold);
+    LSM6DSOXStatusTypeDef Set_Wake_Up_Duration(uint8_t Duration);
+    
+    LSM6DSOXStatusTypeDef Enable_Single_Tap_Detection(LSM6DSOX_SensorIntPin_t IntPin);
+    LSM6DSOXStatusTypeDef Disable_Single_Tap_Detection();
+    LSM6DSOXStatusTypeDef Enable_Double_Tap_Detection(LSM6DSOX_SensorIntPin_t IntPin);
+    LSM6DSOXStatusTypeDef Disable_Double_Tap_Detection();
+    LSM6DSOXStatusTypeDef Set_Tap_Threshold(uint8_t Threshold);
+    LSM6DSOXStatusTypeDef Set_Tap_Shock_Time(uint8_t Time);
+    LSM6DSOXStatusTypeDef Set_Tap_Quiet_Time(uint8_t Time);
+    LSM6DSOXStatusTypeDef Set_Tap_Duration_Time(uint8_t Time);
+    
+    LSM6DSOXStatusTypeDef Enable_6D_Orientation(LSM6DSOX_SensorIntPin_t IntPin);
+    LSM6DSOXStatusTypeDef Disable_6D_Orientation();
+    LSM6DSOXStatusTypeDef Set_6D_Orientation_Threshold(uint8_t Threshold);
+    LSM6DSOXStatusTypeDef Get_6D_Orientation_XL(uint8_t *XLow);
+    LSM6DSOXStatusTypeDef Get_6D_Orientation_XH(uint8_t *XHigh);
+    LSM6DSOXStatusTypeDef Get_6D_Orientation_YL(uint8_t *YLow);
+    LSM6DSOXStatusTypeDef Get_6D_Orientation_YH(uint8_t *YHigh);
+    LSM6DSOXStatusTypeDef Get_6D_Orientation_ZL(uint8_t *ZLow);
+    LSM6DSOXStatusTypeDef Get_6D_Orientation_ZH(uint8_t *ZHigh);
+    
+    LSM6DSOXStatusTypeDef Get_X_DRDY_Status(uint8_t *Status);
+    LSM6DSOXStatusTypeDef Get_X_Event_Status(LSM6DSOX_Event_Status_t *Status);
+    LSM6DSOXStatusTypeDef Set_X_SelfTest(uint8_t Status);
+    
+    LSM6DSOXStatusTypeDef Get_G_DRDY_Status(uint8_t *Status);
+    LSM6DSOXStatusTypeDef Set_G_SelfTest(uint8_t Status);
+    
+    LSM6DSOXStatusTypeDef Get_FIFO_Num_Samples(uint16_t *NumSamples);
+    LSM6DSOXStatusTypeDef Get_FIFO_Full_Status(uint8_t *Status);
+    LSM6DSOXStatusTypeDef Set_FIFO_INT1_FIFO_Full(uint8_t Status);
+    LSM6DSOXStatusTypeDef Set_FIFO_Watermark_Level(uint16_t Watermark);
+    LSM6DSOXStatusTypeDef Set_FIFO_Stop_On_Fth(uint8_t Status);
+    LSM6DSOXStatusTypeDef Set_FIFO_Mode(uint8_t Mode);
+    LSM6DSOXStatusTypeDef Get_FIFO_Tag(uint8_t *Tag);
+    LSM6DSOXStatusTypeDef Get_FIFO_Data(uint8_t *Data);
+    LSM6DSOXStatusTypeDef Get_FIFO_X_Axes(int32_t *Acceleration);
+    LSM6DSOXStatusTypeDef Set_FIFO_X_BDR(float Bdr);
+    LSM6DSOXStatusTypeDef Get_FIFO_G_Axes(int32_t *AngularVelocity);
+    LSM6DSOXStatusTypeDef Set_FIFO_G_BDR(float Bdr);
     
     /**
      * @brief Utility function to read data.
@@ -236,28 +190,44 @@
      * @param  NumByteToRead: number of bytes to be read.
      * @retval 0 if ok, an error code otherwise.
      */
-    uint8_t io_read(uint8_t* pBuffer, uint8_t RegisterAddr, uint16_t NumByteToRead)
+    uint8_t IO_Read(uint8_t* pBuffer, uint8_t RegisterAddr, uint16_t NumByteToRead)
     {        
-        if (_dev_spi) {
-            /* Write Reg Address */
-            _dev_spi->lock();
-            _cs_pin = 0;           
-            if (_spi_type == SPI4W) {            
-                _dev_spi->write(RegisterAddr | 0x80);
-                for (int i=0; i<NumByteToRead; i++) {
-                    *(pBuffer+i) = _dev_spi->write(0x00);
-                }
-            } else if (_spi_type == SPI3W){
-                /* Write RD Reg Address with RD bit*/
-                uint8_t TxByte = RegisterAddr | 0x80;    
-                _dev_spi->write((char *)&TxByte, 1, (char *)pBuffer, (int) NumByteToRead);
-            }            
-            _cs_pin = 1;
-            _dev_spi->unlock(); 
-            return 0;
-        }                       
-        if (_dev_i2c) return (uint8_t) _dev_i2c->i2c_read(pBuffer, _address, RegisterAddr, NumByteToRead);
-        return 1;
+      if (dev_spi) {
+        dev_spi->beginTransaction(SPISettings(spi_speed, MSBFIRST, SPI_MODE3));
+
+        digitalWrite(cs_pin, LOW);
+
+        /* Write Reg Address */
+        dev_spi->transfer(RegisterAddr | 0x80);
+        /* Read the data */
+        for (uint16_t i=0; i<NumByteToRead; i++) {
+          *(pBuffer+i) = dev_spi->transfer(0x00);
+        }
+         
+        digitalWrite(cs_pin, HIGH);
+
+        dev_spi->endTransaction();
+
+        return 0;
+      }
+		
+      if (dev_i2c) {
+        dev_i2c->beginTransmission(((uint8_t)(((address) >> 1) & 0x7F)));
+        dev_i2c->write(RegisterAddr);
+        dev_i2c->endTransmission(false);
+
+        dev_i2c->requestFrom(((uint8_t)(((address) >> 1) & 0x7F)), (uint8_t) NumByteToRead);
+
+        int i=0;
+        while (dev_i2c->available()) {
+          pBuffer[i] = dev_i2c->read();
+          i++;
+        }
+
+        return 0;
+      }
+
+      return 1;
     }
     
     /**
@@ -267,44 +237,70 @@
      * @param  NumByteToWrite: number of bytes to write.
      * @retval 0 if ok, an error code otherwise.
      */
-    uint8_t io_write(uint8_t* pBuffer, uint8_t RegisterAddr, uint16_t NumByteToWrite)
-    {
-        if (_dev_spi) { 
-            _dev_spi->lock();
-            _cs_pin = 0;
-            _dev_spi->write(RegisterAddr);                    
-            _dev_spi->write((char *)pBuffer, (int) NumByteToWrite, NULL, 0);                     
-            _cs_pin = 1;                    
-            _dev_spi->unlock();
-            return 0;                    
-        }        
-        if (_dev_i2c) return (uint8_t) _dev_i2c->i2c_write(pBuffer, _address, RegisterAddr, NumByteToWrite);    
-        return 1;
+    uint8_t IO_Write(uint8_t* pBuffer, uint8_t RegisterAddr, uint16_t NumByteToWrite)
+    {  
+      if (dev_spi) {
+        dev_spi->beginTransaction(SPISettings(spi_speed, MSBFIRST, SPI_MODE3));
+
+        digitalWrite(cs_pin, LOW);
+
+        /* Write Reg Address */
+        dev_spi->transfer(RegisterAddr);
+        /* Write the data */
+        for (uint16_t i=0; i<NumByteToWrite; i++) {
+          dev_spi->transfer(pBuffer[i]);
+        }
+
+        digitalWrite(cs_pin, HIGH);
+
+        dev_spi->endTransaction();
+
+        return 0;                    
+      }
+  
+      if (dev_i2c) {
+        dev_i2c->beginTransmission(((uint8_t)(((address) >> 1) & 0x7F)));
+
+        dev_i2c->write(RegisterAddr);
+        for (uint16_t i = 0 ; i < NumByteToWrite ; i++) {
+          dev_i2c->write(pBuffer[i]);
+        }
+
+        dev_i2c->endTransmission(true);
+
+        return 0;
+      }
+
+      return 1;
     }
 
   private:
-    int set_x_odr_when_enabled(float odr);
-    int set_g_odr_when_enabled(float odr);
-    int set_x_odr_when_disabled(float odr);
-    int set_g_odr_when_disabled(float odr);
+  
+    LSM6DSOXStatusTypeDef Set_X_ODR_When_Enabled(float Odr);
+    LSM6DSOXStatusTypeDef Set_X_ODR_When_Disabled(float Odr);
+    LSM6DSOXStatusTypeDef Set_G_ODR_When_Enabled(float Odr);
+    LSM6DSOXStatusTypeDef Set_G_ODR_When_Disabled(float Odr);
+  
+  
 
     /* Helper classes. */
-    DevI2C *_dev_i2c;
-    SPI    *_dev_spi;
-
+    TwoWire *dev_i2c;
+    SPIClass *dev_spi;
+    
     /* Configuration */
-    uint8_t _address;
-    DigitalOut  _cs_pin;        
-    InterruptIn _int1_irq;
-    InterruptIn _int2_irq;
-    SPI_type_t _spi_type;
-    
-    uint8_t _x_is_enabled;
-    lsm6dsox_odr_xl_t _x_last_odr;
-    uint8_t _g_is_enabled;
-    lsm6dsox_odr_g_t _g_last_odr;
-
-    lsm6dsox_ctx_t _reg_ctx;
+    uint8_t address;
+    int cs_pin;
+    uint32_t spi_speed;
+    
+    lsm6dsox_odr_xl_t acc_odr;
+    lsm6dsox_odr_g_t gyro_odr;
+    
+    uint8_t acc_is_enabled;
+    uint8_t gyro_is_enabled;
+    
+    
+    lsm6dsox_ctx_t reg_ctx;
+    
 };
 
 #ifdef __cplusplus
